<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCARA Adjustment Tool (Manguera)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; color: white; }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(17, 24, 39, 0.9);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }
        .control-group { margin-bottom: 10px; }
        label, select, button { display: block; margin-bottom: 5px; font-size: 14px; color: white; }
        select { 
            background: #374151; border: 1px solid #4b5563; padding: 5px; border-radius: 6px; width: 100%;
            pointer-events: all;
        }
        button { 
            padding: 8px 12px; background: #34d399; color: black; border: none; border-radius: 6px; cursor: pointer;
            transition: background 0.3s; font-weight: bold; pointer-events: all; 
        }
        button:hover { background: #10b981; }
        .hint { font-size: 12px; color: #9ca3af; margin-top: 5px; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="controls">
        <div class="control-group">
            <label for="component-selector">Seleccionar Anclaje a Ajustar:</label>
            <select id="component-selector">
                <option value="none">-- Seleccionar --</option>
            </select>
            <div class="hint">Modo: Mover (T) | Rotar (R) | Escalar (S)</div>
        </div>
        <button id="print-coords">IMPRIMIR CÓDIGOS DE AJUSTE</button>
        <div class="hint">Revisa la consola (F12) para copiar los valores.</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- 1. ESCENA Y SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(60, 60, 80);
        camera.lookAt(0, 10, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 10, 0);

        // Transform Controls Setup
        const transformControls = new TransformControls(camera, renderer.domElement);
        scene.add(transformControls);

        // Luces y Helpers
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const gridHelper = new THREE.GridHelper(100, 20, 0x333333, 0x222222);
        scene.add(gridHelper);
        const axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);

        let controlledMesh = null;
        const componentMap = {};

        // --- 2. CINEMÁTICA Y PROPIEDADES (Fijas) ---
        const KIN_L1 = 29.5;
        const KIN_L2 = 12.3; 
        const KIN_BASE_H = 12.5;
        const KIN_Z_TRAVEL = 5.5;

        const VIS_ARM2_H = 15.0; 
        const VIS_ARM1_H = 2.5;
        const z_retracted_y = (VIS_ARM2_H / 2) - (VIS_ARM1_H / 2);
        const zRodVisualLength = KIN_Z_TRAVEL + (VIS_ARM2_H / 2);

        // Materiales
        const matYellow = new THREE.MeshStandardMaterial({ color: 0xffe01a, roughness: 0.6, metalness: 0.1 });
        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.1 });
        const matSilver = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.2, metalness: 0.8 });
        // Material para los anclajes, ahora más visual
        const matAnchor = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7, roughness: 0.5 });
        const matTube = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.8 }); // Para la catenaria temporal

        // --- 3. GRUPOS CINEMÁTICOS (Fijos) ---
        const baseGroup = new THREE.Group();
        baseGroup.position.set(-11.2767, 0.0000, -7.2834); 
        scene.add(baseGroup);

        const pivotQ1 = new THREE.Group();
        pivotQ1.position.y = KIN_BASE_H; 
        scene.add(pivotQ1);

        const pivotQ2 = new THREE.Group();
        pivotQ2.position.x = KIN_L1; 
        pivotQ1.add(pivotQ2);

        const zPistonGroup = new THREE.Group();
        zPistonGroup.position.x = KIN_L2; 
        zPistonGroup.position.y = z_retracted_y;
        pivotQ2.add(zPistonGroup);

        const gripperGroup = new THREE.Group();
        gripperGroup.position.y = -zRodVisualLength;
        zPistonGroup.add(gripperGroup);

        // --- 4. STL LOADER: Cargamos los modelos STL (Fijos) ---
        const loader = new STLLoader();
        
        function makeMeshFromSTL(geometry, material, componentName, parentGroup, pos, rot, sca) {
            geometry.computeVertexNormals();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.name = componentName;
            
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.rotation.set(rot.x, rot.y, rot.z);
            mesh.scale.set(sca.x, sca.y, sca.z);
            
            parentGroup.add(mesh);
            return mesh;
        }

        const basePath = 'static/models/'; 

        // Base (Ajuste Permanente)
        loader.load(encodeURI(basePath + 'SCARA Base.STL'), geometry => {
            makeMeshFromSTL(geometry, matBlack, 'Base', baseGroup, 
                new THREE.Vector3(0.0000, 0.0000, 0.0000), 
                new THREE.Vector3(0.0000, 0.0000, 0.0000), 
                new THREE.Vector3(0.1000, 0.1000, 0.1000));
        });

        // Eslabon 1 (Ajuste Permanente)
        loader.load(encodeURI(basePath + 'SCARA Eslabon 1.STL'), geometry => {
            makeMeshFromSTL(geometry, matYellow, 'Eslabon 1', pivotQ1, 
                new THREE.Vector3(-7.2181, -4.3781, -6.5986), 
                new THREE.Vector3(0.0000, 0.0490, 0.0000), 
                new THREE.Vector3(0.1000, 0.1000, 0.1000));
        });

        // Eslabon 2 (Ajuste Permanente)
        loader.load(encodeURI(basePath + 'SCARA Eslabon 2.STL'), geometry => {
            makeMeshFromSTL(geometry, matYellow, 'Eslabon 2', pivotQ2, 
                new THREE.Vector3(-29.3145, -4.4546, -4.5607), 
                new THREE.Vector3(0.0000, 0.0256, 0.0000), 
                new THREE.Vector3(0.1000, 0.1000, 0.1000));
        });

        // Grippers (Solo para visualización)
        loader.load(encodeURI(basePath + 'SCARA Gripper abierto.STL'), geometry => {
            makeMeshFromSTL(geometry, matSilver, 'Gripper Abierto', gripperGroup, 
                new THREE.Vector3(-42.2434, 0.4286, -4.6981), 
                new THREE.Vector3(0.0000, 0.0000, 0.0000), 
                new THREE.Vector3(0.1000, 0.1000, 0.1000));
        });
        
        loader.load(encodeURI(basePath + 'SCARA Gripper cerrado.STL'), geometry => {
             const closedMesh = makeMeshFromSTL(geometry, matSilver, 'Gripper Cerrado', gripperGroup, 
                new THREE.Vector3(-42.2434, 0.4286, -4.6981), 
                new THREE.Vector3(0.0000, 0.0000, 0.0000), 
                new THREE.Vector3(0.1000, 0.1000, 0.1000));
            closedMesh.visible = false;
        });

        // --- 5. ANCLAJES DE MANGUERA (Dinámicos y con Orientación) ---
        // Usamos un cilindro para que tenga una dirección clara (apunta a Y por defecto)
        const anchorGeo = new THREE.CylinderGeometry(0.7, 0.7, 2, 16); // Cilindro más delgado
        const anchorScale = new THREE.Vector3(1, 1, 1); // Escala para los anclajes

        // ANCLAJE BASE (P1)
        const cableAnchorBase = new THREE.Mesh(anchorGeo, matAnchor);
        cableAnchorBase.name = 'Anclaje Cable Base';
        // Rotar para que apunte hacia abajo inicialmente (Eje Y del cilindro hacia abajo)
        cableAnchorBase.rotation.x = Math.PI / 2; // Rota 90 grados en X
        cableAnchorBase.position.set(-1.0, KIN_BASE_H + 5, 5); 
        cableAnchorBase.scale.copy(anchorScale);
        baseGroup.add(cableAnchorBase);
        componentMap['Anclaje Cable Base'] = cableAnchorBase;


        // ANCLAJE CODO (P2)
        const cableAnchorCodo = new THREE.Mesh(anchorGeo, matAnchor);
        cableAnchorCodo.name = 'Anclaje Cable Codo';
        cableAnchorCodo.rotation.x = Math.PI / 2; // Rota 90 grados en X
        cableAnchorCodo.position.set(KIN_L2 - 10, z_retracted_y + 5, 5); 
        cableAnchorCodo.scale.copy(anchorScale);
        pivotQ2.add(cableAnchorCodo);
        componentMap['Anclaje Cable Codo'] = cableAnchorCodo;
        
        // Catenaria TEMPORAL con más puntos de control para curvatura
        const tempTubePoints = [
            new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()
        ];
        const tempTubePath = new THREE.CatmullRomCurve3(tempTubePoints);
        let tempTube = new THREE.Mesh(new THREE.TubeGeometry(tempTubePath, 20, 0.8, 8, false), matTube);
        scene.add(tempTube);

        // Función para actualizar la catenaria temporal
        function updateTempCatenary() {
            if (cableAnchorBase && cableAnchorCodo) {
                // Posiciones mundiales de los anclajes (punto de salida de la manguera)
                const p1 = new THREE.Vector3();
                const p2 = new THREE.Vector3();
                cableAnchorBase.getWorldPosition(p1);
                cableAnchorCodo.getWorldPosition(p2);

                // Calcular la dirección "hacia abajo" de cada anclaje
                const p1Dir = new THREE.Vector3(0, -1, 0).applyQuaternion(cableAnchorBase.getWorldQuaternion(new THREE.Quaternion()));
                const p2Dir = new THREE.Vector3(0, -1, 0).applyQuaternion(cableAnchorCodo.getWorldQuaternion(new THREE.Quaternion()));

                // Puntos de control intermedios para la curvatura (tangentes)
                // Se extiende desde el anclaje en la dirección "hacia abajo"
                const control1 = p1.clone().add(p1Dir.multiplyScalar(10)); // Extiende 10 unidades
                const control2 = p2.clone().add(p2Dir.multiplyScalar(10)); // Extiende 10 unidades
                
                // Asegurar que la catenaria tiene una forma razonable, curvando hacia abajo si es necesario
                const midPoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                midPoint.y -= Math.max(0, p1.distanceTo(p2) / 5); // Curvatura basada en la distancia

                // Crear la curva CatmullRom con más puntos para suavidad
                tempTubePath.points = [p1, control1, midPoint, control2, p2];

                tempTube.geometry.dispose();
                tempTube.geometry = new THREE.TubeGeometry(tempTubePath, 60, 0.8, 8, false); // Más segmentos para suavidad
            }
        }


        // --- 6. LÓGICA DE CONTROL ---
        transformControls.addEventListener('dragging-changed', function (event) {
            controls.enabled = !event.value;
            if (!event.value) { // Cuando se suelta el control, actualiza la catenaria
                updateTempCatenary();
            }
        });
        
        transformControls.addEventListener('objectChange', function() {
            // Actualiza la catenaria en tiempo real mientras se arrastra
            updateTempCatenary(); 
        });


        document.getElementById('component-selector').addEventListener('change', (event) => {
            const componentName = event.target.value;
            transformControls.detach();
            controlledMesh = null;
            
            if (componentName !== 'none' && componentMap[componentName]) {
                controlledMesh = componentMap[componentName];
                transformControls.attach(controlledMesh);
                // Permite rotar también para orientar el cilindro del anclaje
                transformControls.setMode('translate'); 
                
                // Ocultar grippers si se selecciona un anclaje
                if (componentMap['Gripper Abierto']) componentMap['Gripper Abierto'].visible = false;
                if (componentMap['Gripper Cerrado']) componentMap['Gripper Cerrado'].visible = false;
            }
            updateTempCatenary(); // Asegura que la catenaria se actualice al cambiar de anclaje
        });

        document.addEventListener('keydown', function (event) {
            switch (event.key) {
                case 't': case 'T': transformControls.setMode('translate'); break;
                case 'r': case 'R': transformControls.setMode('rotate'); break;
                case 's': case 'S': transformControls.setMode('scale'); break;
                case 'e': controls.enabled = false; break;
            }
        });
        
        document.addEventListener('keyup', function (event) {
            if (event.key === 'e') controls.enabled = true;
        });

        document.getElementById('print-coords').addEventListener('click', () => {
            if (!controlledMesh) {
                console.warn('¡ERROR! Selecciona un anclaje para imprimir sus coordenadas de ajuste.');
                return;
            }

            const mesh = controlledMesh;
            const componentName = mesh.name;
            const position = mesh.position;
            const rotation = mesh.rotation; // Ahora también necesitamos la rotación del anclaje
            
            console.log(`\n\n--- CÓDIGOS DE AJUSTE FINAL PARA: ${componentName} ---`);
            console.log(`// Pega estas líneas en la sección de declaración de p1_base o p3_head_helper en panel.html\n`);
            
            console.log(`${componentName} Malla Posición: mesh.position.set(${position.x.toFixed(4)}, ${position.y.toFixed(4)}, ${position.z.toFixed(4)});`);
            console.log(`${componentName} Malla Rotación: mesh.rotation.set(${rotation.x.toFixed(4)}, ${rotation.y.toFixed(4)}, ${rotation.z.toFixed(4)});`);
            console.log('\n--- FIN DE CÓDIGOS DE AJUSTE ---\n');
        });

        // --- 7. ANIMACIÓN / RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.onload = function () {
            animate();
            // Inicializar la catenaria al cargar
            updateTempCatenary(); 
        };

        // Resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Llenar el selector
        window.setTimeout(() => {
            if (componentMap['Anclaje Cable Base']) {
                const selector = document.getElementById('component-selector');
                ['Anclaje Cable Base', 'Anclaje Cable Codo'].forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    selector.appendChild(option);
                });
            }
        }, 1000);
    </script>
</body>
</html>