<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCARA Adjustment Tool (Final)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; color: white; }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(17, 24, 39, 0.9);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }
        .control-group { margin-bottom: 10px; }
        label, select, button { display: block; margin-bottom: 5px; font-size: 14px; color: white; }
        select { 
            background: #374151; border: 1px solid #4b5563; padding: 5px; border-radius: 6px; width: 100%;
            pointer-events: all;
        }
        button { 
            padding: 8px 12px; background: #34d399; color: black; border: none; border-radius: 6px; cursor: pointer;
            transition: background 0.3s; font-weight: bold; pointer-events: all; 
        }
        button:hover { background: #10b981; }
        .hint { font-size: 12px; color: #9ca3af; margin-top: 5px; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="controls">
        <div class="control-group">
            <label for="component-selector">Seleccionar Pieza a Ajustar:</label>
            <select id="component-selector">
                <option value="none">-- Seleccionar --</option>
            </select>
            <div class="hint">Modo: Mover (T) | Rotar (R) | Escalar (S)</div>
        </div>
        <button id="print-coords">IMPRIMIR CÓDIGOS DE AJUSTE</button>
        <div class="hint">Revisa la consola (F12) para copiar los valores.</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- 1. ESCENA Y SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(60, 60, 80);
        camera.lookAt(0, 10, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 10, 0);

        // Transform Controls Setup
        const transformControls = new TransformControls(camera, renderer.domElement);
        scene.add(transformControls);

        // Luces y Helpers
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const gridHelper = new THREE.GridHelper(100, 20, 0x333333, 0x222222);
        scene.add(gridHelper);
        const axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);

        let controlledMesh = null;
        const componentMap = {};

        // --- 2. CINEMÁTICA Y PROPIEDADES ---
        const KIN_L1 = 28.9818176; 
        const KIN_L2 = 12.4700356; 
        const KIN_BASE_H = 12.3;
        const KIN_Z_TRAVEL = 5.5;

        const VIS_ARM2_H = 15.0; 
        const VIS_ARM1_H = 2.5;
        const z_retracted_y = (VIS_ARM2_H / 2) - (VIS_ARM1_H / 2);
        const zRodVisualLength = KIN_Z_TRAVEL + (VIS_ARM2_H / 2);

        // Materiales
        const matYellow = new THREE.MeshStandardMaterial({ color: 0xffe01a, roughness: 0.6, metalness: 0.1 });
        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.1 });
        const matSilver = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.2, metalness: 0.8 });
        
        // --- 3. GRUPOS CINEMÁTICOS ---
        const baseGroup = new THREE.Group();
        // ** NUEVO VALOR CORREGIDO DEL GRUPO BASE **
        baseGroup.position.set(0.06407084, 0.00000000, -0.05865405); 
        scene.add(baseGroup);

        const pivotQ1 = new THREE.Group();
        pivotQ1.position.y = KIN_BASE_H;
        scene.add(pivotQ1);

        const pivotQ2 = new THREE.Group();
        pivotQ2.position.x = KIN_L1;
        pivotQ1.add(pivotQ2);

        const zPistonGroup = new THREE.Group();
        zPistonGroup.position.x = KIN_L2; 
        zPistonGroup.position.y = z_retracted_y;
        pivotQ2.add(zPistonGroup);

        const gripperGroup = new THREE.Group();
        gripperGroup.position.y = -zRodVisualLength;
        zPistonGroup.add(gripperGroup);

        // --- 4. STL LOADER ---
        const loader = new STLLoader();
        
        function makeMeshFromSTL(geometry, material, componentName, parentGroup, pos, rot, sca) {
            geometry.computeVertexNormals();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.name = componentName;
            
            // Aplicar coordenadas
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.rotation.set(rot.x, rot.y, rot.z);
            mesh.scale.set(sca.x, sca.y, sca.z);
            
            parentGroup.add(mesh);
            componentMap[componentName] = mesh;
            return mesh;
        }

        const basePath = '/static/models/'; 
        const SCALE_FACTOR = 0.1; 
        
        function updateSelector(componentName) {
            const selector = document.getElementById('component-selector');
            const option = document.createElement('option');
            option.value = componentName;
            option.textContent = componentName;
            selector.appendChild(option);
        }

        // --- CARGA DE MODELOS CON VALORES CORREGIDOS ---

        // 1) Base
        loader.load(encodeURI(basePath + 'BASE.STL'), geometry => {
            makeMeshFromSTL(geometry, matBlack, 'Base', baseGroup, 
                new THREE.Vector3(-8.97822321, 0.08975486, 8.09219703), 
                new THREE.Vector3(-1.57079633, 0.00000000, 0.00000000), 
                new THREE.Vector3(0.1000, 0.1000, 0.1000));
            updateSelector('Base');
        });

        // 2) Eslabon 1
        loader.load(encodeURI(basePath + 'ESLABON1.STL'), geometry => {
            makeMeshFromSTL(geometry, matYellow, 'Eslabon 1', pivotQ1, 
                new THREE.Vector3(-2.04580879, -2.07388049, 2.10588280), 
                new THREE.Vector3(-1.56453459, 0.00322540, 0.00028688), 
                new THREE.Vector3(0.1000, 0.1000, 0.1000));
            updateSelector('Eslabon 1');
        });

        // 3) Eslabon 2
        loader.load(encodeURI(basePath + 'ESLABON123.STL'), geometry => {
            makeMeshFromSTL(geometry, matYellow, 'Eslabon 2', pivotQ2, 
                new THREE.Vector3(-27.39266117, -2.28102540, 1.92693333), 
                new THREE.Vector3(-1.55928971, -0.00962069, -0.01701746), 
                new THREE.Vector3(0.1000, 0.1000, 0.1000));
            updateSelector('Eslabon 2');
        });

        // 4) Gripper Abierto
        loader.load(encodeURI(basePath + 'ESLABONFINAL.STL'), geometry => {
            componentMap['Gripper Abierto'] = makeMeshFromSTL(geometry, matSilver, 'Gripper Abierto', gripperGroup, 
                new THREE.Vector3(-39.97702533, 2.43567520, 1.21721535), 
                new THREE.Vector3(-1.54949239, 0.00000000, 0.00000000), 
                new THREE.Vector3(0.1000, 0.1000, 0.1000));
            updateSelector('Gripper Abierto');
        });
        
        // 5) Gripper Cerrado (Mismas coords que abierto)
        loader.load(encodeURI(basePath + 'ESLABONFINAL.STL'), geometry => {
             const closedMesh = makeMeshFromSTL(geometry, matSilver, 'Gripper Cerrado', gripperGroup, 
                new THREE.Vector3(-39.97702533, 2.43567520, 1.21721535), 
                new THREE.Vector3(-1.54949239, 0.00000000, 0.00000000), 
                new THREE.Vector3(0.1000, 0.1000, 0.1000));
            closedMesh.visible = false;
            componentMap['Gripper Cerrado'] = closedMesh;
        });

        // --- 5. LÓGICA DE CONTROL ---
        
        transformControls.addEventListener('dragging-changed', function (event) {
            controls.enabled = !event.value;
        });

        document.getElementById('component-selector').addEventListener('change', (event) => {
            const componentName = event.target.value;
            transformControls.detach();
            controlledMesh = null;
            
            if (componentName !== 'none' && componentMap[componentName]) {
                controlledMesh = componentMap[componentName];
                transformControls.attach(controlledMesh);
                
                if (componentName === 'Base') {
                    transformControls.attach(baseGroup);
                } else {
                     transformControls.attach(controlledMesh);
                }
            }
        });

        document.addEventListener('keydown', function (event) {
            switch (event.key) {
                case 't': case 'T': transformControls.setMode('translate'); break;
                case 'r': case 'R': transformControls.setMode('rotate'); break;
                case 's': case 'S': transformControls.setMode('scale'); break;
                case 'e': controls.enabled = false; break;
            }
        });
        
        document.addEventListener('keyup', function (event) {
            if (event.key === 'e') controls.enabled = true;
        });

        document.getElementById('print-coords').addEventListener('click', () => {
            if (!controlledMesh) {
                console.warn('¡ERROR! Selecciona una pieza para imprimir sus coordenadas.');
                return;
            }

            const mesh = controlledMesh;
            const componentName = mesh.name;
            const position = mesh.position;
            const rotation = mesh.rotation;
            const scale = mesh.scale;
            
            console.log(`\n\n--- CÓDIGOS DE AJUSTE PARA: ${componentName} ---`);
            
            if (componentName === 'Base') {
                const groupPos = baseGroup.position;
                console.log(`baseGroup.position.set(${groupPos.x.toFixed(8)}, ${groupPos.y.toFixed(8)}, ${groupPos.z.toFixed(8)});`);
            }
            
            console.log(`${componentName} Malla Posición: mesh.position.set(${position.x.toFixed(8)}, ${position.y.toFixed(8)}, ${position.z.toFixed(8)});`);
            console.log(`${componentName} Malla Rotación: mesh.rotation.set(${rotation.x.toFixed(8)}, ${rotation.y.toFixed(8)}, ${rotation.z.toFixed(8)});`);
            console.log(`${componentName} Malla Escala: mesh.scale.set(${scale.x.toFixed(8)}, ${scale.y.toFixed(8)}, ${scale.z.toFixed(8)});`);
            console.log('\n--- FIN DE CÓDIGOS DE AJUSTE ---\n');
        });

        // --- 6. ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.onload = function () {
            animate();
        };

        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>